# BlogAuto 블로그 생성 로직 상세 설명

## 🔄 전체 워크플로우

```
사용자 입력 → 입력 검증 → API 키 저장 → 네이버 블로그 검색 → 검색 결과 저장 
→ Claude AI 프롬프트 생성 → Claude API 호출 → 성공/실패 분기 → 블로그 글 저장 → 클라이언트 응답
```

### 워크플로우 다이어그램
```
┌─────────────┐    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│  사용자입력  │───▶│  입력검증   │───▶│ API키저장   │───▶│네이버블로그  │
│            │    │            │    │            │    │    검색     │
└─────────────┘    └─────────────┘    └─────────────┘    └─────────────┘
                                                                 │
┌─────────────┐    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│클라이언트응답│◀───│ 블로그글저장 │◀───│Claude AI호출│◀───│검색결과저장  │
│            │    │            │    │            │    │            │
└─────────────┘    └─────────────┘    └─────────────┘    └─────────────┘
                                              │
                                     ┌─────────────┐
                                     │대체콘텐츠생성│
                                     │  (실패시)   │
                                     └─────────────┘
```

## 1️⃣ 입력 단계 (`/search-and-generate` API)

### 엔드포인트
```javascript
POST /search-and-generate
Content-Type: application/json
```

### 필수 입력 데이터
```javascript
{
  "keyword": "블로그 주제 키워드",
  "aiPrompt": "사용자 요청사항 (글쓰기 스타일)",
  "naverClientId": "네이버 API 클라이언트 ID",
  "naverClientSecret": "네이버 API 클라이언트 시크릿",
  "claudeApiKey": "Claude AI API 키"
}
```

### 입력 검증 로직
```javascript
if (!keyword || !aiPrompt || !naverClientId || !naverClientSecret || !claudeApiKey) {
    return res.status(400).json({ error: '모든 필드를 입력해주세요.' });
}
```

**검증 항목:**
- 모든 필드가 존재하는지 확인
- 빈 문자열이 아닌지 검증
- 필수 파라미터 누락 시 400 에러 반환

## 2️⃣ API 키 저장 (`saveApiKeys`)

### 저장 구조
```javascript
const apiData = {
    naverClientId: naverClientId,
    naverClientSecret: naverClientSecret,
    claudeApiKey: claudeApiKey,
    lastUpdated: new Date().toISOString()
};
```

### 저장 위치
- **파일 경로**: `./api.txt`
- **형식**: JSON
- **인코딩**: UTF-8

### 저장 목적
- API 키 재사용으로 사용자 편의성 향상
- 다음 요청 시 자동 로드
- 설정 페이지에서 기존 값 표시

### 보안 고려사항
⚠️ **주의**: 현재 평문 저장, 프로덕션 환경에서는 암호화 필요

## 3️⃣ 네이버 블로그 검색 (`searchNaverBlogs`)

### API 호출 설정
```javascript
const response = await axios.get('https://openapi.naver.com/v1/search/blog.json', {
    params: {
        query: keyword,        // 검색 키워드
        display: 5,           // 결과 개수 (5개)
        start: 1,             // 시작 위치 (1부터)
        sort: 'sim'           // 정확도순 정렬
    },
    headers: {
        'X-Naver-Client-Id': clientId,
        'X-Naver-Client-Secret': clientSecret
    }
});
```

### 검색 파라미터 상세
- **query**: 사용자 입력 키워드
- **display**: 5개 (충분한 참고 자료, 과도하지 않은 양)
- **start**: 1 (상위 결과부터)
- **sort**: 'sim' (정확도순, 키워드 관련성 최대화)

### 에러 처리
```javascript
if (error.response && error.response.status === 401) {
    throw new Error('네이버 API 키가 유효하지 않습니다.');
} else if (error.response && error.response.status === 429) {
    throw new Error('네이버 API 호출 한도를 초과했습니다.');
} else {
    throw new Error('네이버 검색 API 호출 실패: ' + error.message);
}
```

### 반환 데이터 구조
```javascript
[
  {
    title: "블로그 제목 (HTML 태그 포함)",
    description: "블로그 내용 요약 (HTML 태그 포함)",
    link: "블로그 원문 URL",
    bloggername: "블로거명",
    bloggerlink: "블로그 링크",
    postdate: "작성일 (YYYYMMDD)"
  }
]
```

## 4️⃣ 검색 결과 저장 (`saveSearchResults`)

### 듀얼 저장 전략
블로그 자동 작성기는 **이중화된 저장 시스템**을 사용합니다:

#### 1차 저장: Firestore (클라우드)
```javascript
const data = {
    keyword: keyword,
    aiPrompt: aiPrompt,
    searchResults: searchResults,
    timestamp: new Date().toISOString(),
    createdAt: admin.firestore.FieldValue.serverTimestamp()
};

if (db) {
    await db.collection('searchResults').add(data);
    console.log('검색 결과가 Firestore에 저장되었습니다.');
}
```

#### 2차 저장: 로컬 파일 (`blogtop.txt`)
```javascript
let content = '=== 네이버 블로그 검색 결과 ===\n\n';

searchResults.forEach((item, index) => {
    const title = item.title.replace(/<[^>]*>/g, '');
    const description = item.description.replace(/<[^>]*>/g, '');
    
    content += `${index + 1}. 제목: ${title}\n`;
    content += `   내용: ${description}\n`;
    content += `   링크: ${item.link}\n\n`;
});

await fs.promises.writeFile('blogtop.txt', content, 'utf8');
```

### 저장 목적
- **이력 관리**: 모든 검색 기록 보존
- **재사용**: 동일 키워드 재검색 시 참조
- **백업**: Firebase 장애 시 로컬 파일 사용
- **디버깅**: 검색 결과 품질 확인

## 5️⃣ Claude AI 프롬프트 생성 (`generateBlogContent`)

### 데이터 소스 선택 로직
```javascript
let blogTopContent;
try {
    if (db) {
        // Firestore에서 최신 검색 결과 조회
        const snapshot = await db.collection('searchResults')
            .where('keyword', '==', keyword)
            .orderBy('timestamp', 'desc')
            .limit(1)
            .get();
        
        if (!snapshot.empty) {
            const data = snapshot.docs[0].data();
            blogTopContent = formatSearchResultsForPrompt(data.searchResults);
        }
    }
} catch (error) {
    console.log('Firestore에서 검색 결과 읽기 실패, 로컬 파일 사용');
    blogTopContent = await fs.promises.readFile('blogtop.txt', 'utf8');
}
```

### 프롬프트 구조 설계
```javascript
const prompt = `다음은 "${keyword}"에 대한 네이버 블로그 검색 결과입니다:

${blogTopContent}

위의 내용을 참조하여 "${keyword}"에 대한 블로그 글을 작성해주세요.

사용자 요청사항:
${aiPrompt}

기본 요구사항:
1. 네이버 검색 상위 노출을 위한 SEO 최적화 적용
2. 약 2000자 내외의 분량
3. 키워드를 자연스럽게 포함 (키워드 밀도 2-3%)
4. 제목, 소제목 구조 활용
5. 읽기 쉽고 유익한 내용
6. 관련 키워드도 자연스럽게 포함

형식:
- 메인 제목 (H1)
- 소제목들 (H2, H3)
- 본문 내용
- 마무리

사용자의 요청사항을 우선적으로 반영하면서 SEO 최적화 요소도 고려하여 한국어로 작성해주세요.`;
```

### 프롬프트 설계 원칙
1. **컨텍스트 제공**: 네이버 검색 결과로 참고 자료 제공
2. **사용자 우선**: AI 프롬프트를 최우선으로 반영
3. **SEO 최적화**: 검색 엔진 친화적 구조 지시
4. **적정 분량**: 2000자 내외 (읽기 적합한 길이)
5. **구조화**: 제목-소제목-본문 계층 구조
6. **자연스러움**: 키워드를 억지로 넣지 않고 자연스럽게 포함

## 6️⃣ Claude API 호출

### API 설정
```javascript
const anthropic = new Anthropic({
    apiKey: claudeApiKey,
});

const message = await anthropic.messages.create({
    model: "claude-3-haiku-20240307",  // 빠르고 비용 효율적
    max_tokens: 3000,                  // 약 2000자 한글 생성 가능
    messages: [
        {
            role: "user",
            content: prompt
        }
    ]
});
```

### 모델 선택 이유
- **claude-3-haiku-20240307**: 
  - 빠른 응답 속도 (2-3초)
  - 비용 효율적 (sonnet 대비 1/5 비용)
  - 블로그 글 품질 충분
  - 한국어 처리 능력 우수

### 토큰 설정
- **max_tokens: 3000**: 
  - 한글 1자 ≈ 1.5토큰
  - 3000토큰 ≈ 2000자 한글
  - 충분한 여유분 확보

### 에러 처리
```javascript
if (error.status === 401) {
    throw new Error('Claude API 키가 유효하지 않습니다.');
} else if (error.status === 429) {
    throw new Error('Claude API 할당량이 초과되었습니다.');
} else {
    throw new Error('Claude API 호출 실패: ' + error.message);
}
```

## 7️⃣ 대체 콘텐츠 생성 (`generateFallbackContent`)

### 실행 조건
Claude API 호출이 실패했을 때 자동으로 실행됩니다:

```javascript
try {
    generatedContent = await generateBlogContent(keyword, aiPrompt, claudeApiKey);
} catch (error) {
    console.error('Claude API 실패, 대체 콘텐츠 생성:', error.message);
    generatedContent = generateFallbackContent(keyword, searchResults, aiPrompt);
}
```

### 대체 콘텐츠 생성 로직
```javascript
function generateFallbackContent(keyword, searchResults, aiPrompt) {
    let content = `# ${keyword}에 대한 종합 가이드\n\n`;
    
    content += `## 개요\n`;
    content += `${keyword}에 대해 알아보겠습니다. 다양한 정보를 통해 ${keyword}의 중요한 측면들을 살펴보겠습니다.\n\n`;
    
    if (aiPrompt) {
        content += `## 작성 방향\n`;
        content += `${aiPrompt}\n\n`;
    }
    
    content += `## 주요 내용\n\n`;
    
    searchResults.forEach((item, index) => {
        const title = item.title.replace(/<[^>]*>/g, '');
        const description = item.description.replace(/<[^>]*>/g, '');
        
        content += `### ${index + 1}. ${title}\n`;
        content += `${description}\n\n`;
        content += `자세한 내용은 [여기서 확인하세요](${item.link})\n\n`;
    });
    
    content += `## 결론\n`;
    content += `${keyword}에 대한 다양한 정보를 살펴보았습니다. 위의 자료들을 참고하여 ${keyword}에 대해 더 깊이 있게 이해할 수 있을 것입니다.\n\n`;
    
    return content;
}
```

### 대체 콘텐츠 특징
- **구조화**: 제목-개요-내용-결론 구조
- **SEO 기본**: 키워드 포함 및 적절한 분량
- **참고 링크**: 네이버 검색 결과 원문 링크 제공
- **사용자 요청 반영**: AI 프롬프트 내용 포함

## 8️⃣ 최종 저장 (`saveBlogPost`)

### 저장 데이터 구조
```javascript
const data = {
    keyword: keyword,                    // 검색 키워드
    aiPrompt: aiPrompt,                 // 사용자 요청사항
    searchResults: searchResults,        // 네이버 검색 결과
    generatedContent: generatedContent,  // 생성된 블로그 글
    timestamp: new Date().toISOString(), // 생성 시간
    createdAt: admin.firestore.FieldValue.serverTimestamp()  // Firebase 서버 시간
};
```

### 저장 위치
- **Firestore**: `blogPosts` 컬렉션
- **로컬 백업**: 현재 미구현 (향후 확장 가능)

### 저장 목적
- **결과 보존**: 생성된 모든 블로그 글 이력 관리
- **품질 분석**: 생성 품질 및 패턴 분석
- **재활용**: 유사 키워드 검색 시 참고 자료
- **사용자 기록**: 개인별 생성 이력 추적

## 9️⃣ 클라이언트 응답

### 성공 응답 구조
```javascript
{
    "success": true,
    "message": "블로그 글 생성 완료",
    "content": "생성된 블로그 글 전체 내용",
    "searchResults": [
        {
            "title": "검색 결과 제목",
            "description": "검색 결과 요약",
            "link": "원문 링크"
        }
    ]
}
```

### 에러 응답 구조
```javascript
{
    "success": false,
    "error": "구체적인 오류 메시지"
}
```

### 응답 활용
- **content**: 사용자에게 생성된 블로그 글 표시
- **searchResults**: 참고한 네이버 검색 결과 표시
- **success**: 프론트엔드에서 성공/실패 분기 처리

## 🔧 핵심 특징 및 장점

### 1. 내구성 (Resilience)
- **이중화 저장**: Firestore ↔ 로컬 파일
- **API 대체**: Claude API ↔ 대체 콘텐츠 생성
- **다단계 에러 처리**: 각 단계별 세밀한 예외 처리

### 2. SEO 최적화
- **키워드 밀도**: 2-3% 자연스러운 포함
- **구조화**: H1, H2, H3 계층 구조
- **최적 분량**: 2000자 내외 (SEO 최적)
- **관련 키워드**: 네이버 검색 결과 기반 연관어 포함

### 3. 사용자 경험
- **빠른 응답**: Haiku 모델 사용으로 2-3초 생성
- **개인화**: AI 프롬프트로 맞춤형 스타일
- **투명성**: 검색 결과와 생성 글 모두 표시
- **신뢰성**: 네이버 상위 블로그 기반 신뢰할 수 있는 정보

### 4. 데이터 무결성
- **완전한 추적**: 입력-검색-생성 전 과정 저장
- **타임스탬프**: 정확한 시간 기록
- **버전 관리**: 검색 결과와 생성 글 분리 저장
- **재현 가능**: 동일 조건으로 재생성 가능

### 5. 확장성
- **모듈화**: 각 단계별 독립적 함수
- **설정 가능**: 검색 개수, 모델, 토큰 수 조정 가능
- **API 교체**: 다른 검색 엔진, AI 모델 쉽게 교체
- **다국어**: 프롬프트 수정으로 다국어 지원 가능

## 🚀 성능 최적화

### 응답 시간 분석
1. **네이버 API 호출**: 0.5-1초
2. **Firestore 저장**: 0.2-0.5초
3. **Claude API 호출**: 2-3초
4. **데이터 처리**: 0.1초
5. **총 소요 시간**: 약 3-5초

### 비용 최적화
- **Claude Haiku**: 최저 비용 모델 사용
- **적정 토큰**: 3000토큰으로 최소화
- **캐싱**: API 키 재사용으로 설정 시간 단축

### 리소스 효율성
- **메모리**: 검색 결과만 메모리 보관, 즉시 저장
- **네트워크**: 병렬 처리 없이 순차 실행으로 안정성 확보
- **스토리지**: 텍스트 데이터만 저장, 미디어 제외

이 블로그 생성 로직은 **신뢰성**, **품질**, **사용자 경험**을 모두 만족하는 완전 자동화 시스템입니다.